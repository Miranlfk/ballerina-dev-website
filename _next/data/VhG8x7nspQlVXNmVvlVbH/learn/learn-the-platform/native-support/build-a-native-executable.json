{"pageProps":{"frontmatter":{"title":"Build a Native Executable [Experimental]","permalink":"/learn/build-a-native-executable/","description":"This guide walks you through compiling a Ballerina application to a native executable and packing the native executable in a container.","keywords":"ballerina, programming language, restful-api, ballerina packages, language-guide","active":"build-a-native-executable","intro":"This guide walks you through compiling a Ballerina application to a native executable and packing the native executable in a container."},"content":"\nThis guide walks you through compiling a Ballerina application to a native executable and packing the native executable in a container. This feature is introduced as an experimental feature in update3 and hopes to make it official with the following releases. In case you come across any issues do report them as the Ballerina team will be aggressively addressing them.\n\nBefore getting started, let's first understand some key aspects which can be helpful to understand  the native executable generating process better.\n\n## GraalVM\n\nBuilding a Ballerina native executable requires the [GraalVM](https://www.graalvm.org) [native-image](https://www.graalvm.org/22.3/reference-manual/native-image/) compiler. GraalVM is a high-performance, cloud native and polyglot JDK designed to accelerate the execution of applications. There are three different distributions on GraalVM: Oracle GraalVM Community Edition (CE), Oracle GraalVM Enterprise Edition (EE) and Mandrel. You can install any to use Ballerina native functionality.\n\n- GraalVM CE is the free version of GraalVM which is distributed under GPLv2+CE at the time of this writing.\n- GraaLVM EE is the paid version of GraalVM which comes with a few additional features such as options for GC, debugging and other optimizations.\n- Mandrel is a downstream distribution of the Oracle GraalVM CE which is maintained by RedHat.\n\nThis article uses GraalVM CE to discuss the following topics.\n\n## Native Executable vs Uber Jar\n\nWhen compiling a  Ballerina application using bal build, the output is an uber jar. As you already know, running the jar requires a JVM. JVM uses Just In Time (JIT) compiler to generate native code during runtime.\n\nOn the other hand, when compiling a Ballerina application using `bal build --native`, the output is the native executable local to the host machine. In order to build the native executable, GraalVM uses Ahead Of Time compilation (AOT) which requires the generated uber jar as the input to produce the native executable. Native Image generation performs aggressive optimizations such as unused code elimination in the JDK and its dependencies, heap snapshotting, and static code initializations.\n\nThe difference between the both approaches result in different pros and cons as depicted in the below diagram.\n\nThe following spider graph illustrates the key differences:\n\n![AOT Vs JIT](/learn/images/aot-vs-jit.jpeg)\n\nAs depicted in the image, AOT compilation with GraalVM provides the following advantages over the standard JIT compilation, making it ideal for container runtimes.\n- Use a fraction of the resources required by the JVM.\n- Applications start in milliseconds.\n- Deliver peak performance immediately, no warmup.\n- Can be packaged into lightweight container images for faster and more efficient deployments.\n- Reduced attack surface.\n\nThe only downside is, the GraalVM native Image build is a highly complicated process which may consume a lot of memory and CPU, resulting in extended build time. However, the GraalVM community is continuously working on improving its performance.\n\n## Ballerina Native Image\n\nFrom Ballerina 2201.3.0 (SwanLake), Ballerina supports GraalVM AOT compilation to generate standalone executables by passing the native flag in the build command: `bal build --native` . The generated executable contains the modules in the current package, their dependencies, Ballerina runtime, and statically linked native code from the JDK.\n\n## Build a native executable locally\n\n### Set up the prerequisites\n\nTo complete this part of the guide, you need:\n1. [Ballerina 2201.3.0 (Swan Lake)](/learn/install-ballerina/set-up-ballerina/) or greater\n2. A text editor\n   >**Tip:** Preferably, <a href=\"https://code.visualstudio.com/\" target=\"_blank\">Visual Studio Code</a> with the  <a href=\"https://marketplace.visualstudio.com/items?itemName=WSO2.ballerina\" target=\"_blank\">Ballerina extension</a> installed.\n3. GraalVM installed and configured appropriately\n4. A command terminal\n\n### Configure GraalVM\n\n1. Install GraalVM if you have not already.\n    - Install GraalVM with one line!\n      ```\n      $ bash <(curl -sL https://get.graalvm.org/jdk)  graalvm-ce-java11-22.3.0\n      ```\n      > **Tip:** Above command does install the native-image tool which is required to generate the native images along with GraalVM.\n    - For additional information check [GraalVM startup guide](https://www.graalvm.org/22.2/docs/getting-started/)\n2. Configure the runtime environment. Set the `GRAALVM_HOME` environment variable to the GraalVM installation directory as directed at the end of the execution of the above command.\n\n> **Note:** On Windows, Native Image requires Visual Studio Code and Microsoft Visual C++(MSVC). Follow this [guide](https://medium.com/graalvm/using-graalvm-and-native-image-on-windows-10-9954dc071311) to install Visual Studio Code with the Windows 10 SDK.\n\nSince the environment is set up for building a native executable, let's see how to build a  native executable for a simple Ballerina HTTP server application.\n\n### Build a native executable\n\n1. Create a ballerina service package :\n   ```\n   $ bal new hello_world -t service\n   ```\n\n2. Replace the content of the file service.bal :\n   ```ballerina\n   import ballerina/http;\n\n   listener http:Listener httpListener = new (8080);\n   service / on httpListener {\n       resource function get greeting() returns string { \n              return \"Hello, World!\"; \n       }\n   }\n   ```\n\n3. Create native executable :\n   ```\n   $ bal build --native\n   WARNING : Native image generation is an experimental feature, which supports only a limited set of functionality\n   Compiling source\n       user/hello_world:0.1.0\n\n   Generating executable\n       target/bin/hello_world.jar\n\n   Generating GraalVM native image\n   ================================================================================================================\n   GraalVM Native Image: Generating 'hello_world' (executable)...\n   ================================================================================================================\n   [1/7] Initializing...                                                                           (15.7s @ 0.40GB)\n    Version info: 'GraalVM 22.3.0 Java 11 CE'\n    Java version info: '11.0.17+8-jvmci-22.3-b08'\n    C compiler: cc (apple, x86_64, 14.0.0)\n    Garbage collector: Serial GC\n    2 user-specific feature(s)\n    - com.oracle.svm.thirdparty.gson.GsonFeature\n    - io.ballerina.stdlib.crypto.svm.BouncyCastleFeature\n   [2/7] Performing analysis...  [************]                                                   (269.1s @ 4.48GB)\n     24,836 (94.74%) of 26,215 classes reachable\n     81,216 (82.54%) of 98,394 fields reachable\n    145,899 (76.07%) of 191,785 methods reachable\n      1,392 classes,   712 fields, and 2,478 methods registered for reflection\n         91 classes,    94 fields, and    66 methods registered for JNI access\n          6 native libraries: -framework CoreServices, -framework Foundation, dl, pthread, stdc++, z\n   [3/7] Building universe...                                                                      (33.3s @ 3.25GB)\n   [4/7] Parsing methods...      [******]                                                          (43.7s @ 3.12GB)\n   [5/7] Inlining methods...     [***]                                                             (12.4s @ 4.63GB)\n   [6/7] Compiling methods...    [***************]                                                (230.8s @ 4.54GB)\n   [7/7] Creating image...                                                                         (19.1s @ 5.45GB)\n     88.47MB (60.32%) for code area:   105,528 compilation units\n     57.72MB (39.36%) for image heap:  478,129 objects and 30 resources\n    484.48KB ( 0.32%) for other data\n    146.66MB in total\n   ---------------------------------------------------------------------------------------------------------------\n   Top 10 packages in code area:                          Top 10 object types in image heap:\n     17.96MB ballerina.http/2                               15.60MB byte[] for code metadata\n      4.49MB ballerina.http/2.types                          9.81MB byte[] for embedded resources\n      2.58MB ballerina.io/1                                  6.59MB java.lang.Class\n      1.85MB ballerina.file/1                                5.02MB byte[] for java.lang.String\n      1.72MB ballerina.jwt/2                                 4.62MB java.lang.String\n      1.57MB sun.security.ssl                                3.58MB byte[] for general heap data\n      1.30MB ballerina.oauth2/2                              2.27MB com.oracle.svm.core.hub.DynamicHubCompanion\n      1.23MB java.lang.invoke                                1.26MB byte[] for reflection metadata\n      1.18MB com.sun.media.sound                           959.04KB java.lang.String[]\n   1011.31KB ballerina.lang$0046query/0                    919.38KB c.o.svm.core.hub.DynamicHub$ReflectionMetadata\n     52.84MB for 847 more packages                           6.45MB for 3500 more object types\n   ----------------------------------------------------------------------------------------------------------------\n               103.7s (15.9% of total time) in 62 GCs | Peak RSS: 5.65GB | CPU load: 2.53\n   ----------------------------------------------------------------------------------------------------------------\n   Produced artifacts:\n    /Users/user/Documents/GraalVM/mocking-test/hello_world/target/bin/hello_world (executable)\n    /Users/user/Documents/GraalVM/mocking-test/hello_world/target/bin/hello_world.build_artifacts.txt (txt)\n   ================================================================================================================\n   Finished generating 'hello_world' in 4m 16s.\n\n   GraalVM image generated\n       /Users/user/Documents/GraalVM/mocking-test/hello_world/target/bin/hello_world\n   ```\n\n   > **Note:** On Windows, the Microsoft Native Tools for Visual Studio must first be initialized before building a native-image. You can do this by starting the x64 Native Tools Command Prompt that was installed with the Visual Studio Build Tools. At x64 Native Tools Command Prompt you can navigate to your project folder and run `bal build --native`.\n\n4. Running the native executable :\n   ```\n   $ ./target/bin/hello_world\n   ```\n\n5. Testing the service with a curl request :\n   ```\n   $ curl http://localhost:8080/greeting\n   Hello, World!\n   ```\n\nGreat! Now you have built and tested a native executable for a simple Ballerina HTTP server application. Let’s see how to build the native executable and pack it in a container.\n\n## Pack the native executable in a container\n\n### Set up the prerequisites\n\nTo complete this part of the guide, you need:\n1. [Ballerina 2201.3.0 (Swan Lake)](/learn/install-ballerina/set-up-ballerina/) or greater\n2. A text editor\n   >**Tip:** Preferably, <a href=\"https://code.visualstudio.com/\" target=\"_blank\">Visual Studio Code</a> with the  <a href=\"https://marketplace.visualstudio.com/items?itemName=WSO2.ballerina\" target=\"_blank\">Ballerina extension</a> installed.\n3. [Docker](https://www.docker.com) installed and configured in your machine\n4. A command terminal\n\n### Build a native executable in a container\n\n1. Create a ballerina service package :\n   ```\n   $ bal new hello_docker -t service\n   ```\n\n2. Replace the content of the file service.bal :\n   ```ballerina\n   import ballerina/http;\n\n   listener http:Listener helloEP = new(8080);\n\n   service / on helloEP {\n       resource function get greeting() returns string {   \n              return \"Hello, Docker!\";   \n       }\n   }\n   ```\n\n3. Generate the artifacts with native executable\n    ```\n   $ bal build --native --cloud=docker\n   Compiling source\n       user/hello_docker:0.1.0\n\n   Generating executable\n\n   Generating artifacts\n\n   Building the native image. This my take a while\n\n   Sending build context to Docker daemon  34.99MB\n   Step 1/11 : FROM ballerina/native-builder:latest as build\n   latest: Pulling from ballerina/native-builder\n   e54b73e95ef3: Pull complete \n   610e102c116f: Pull complete \n   1c4500f6be50: Pull complete \n   6d96a89dde23: Pull complete \n   Digest: sha256:ad5bccc29f6f317283454c16321cce8d7521273032cf346364eb32b077abac0f\n   Status: Downloaded newer image for ballerina/native-builder:latest\n    ---> a8caa408cd81\n   Step 2/11 : WORKDIR /app/build\n    ---> Running in 14262200d0d3\n   Removing intermediate container 14262200d0d3\n    ---> 750b429d3412\n   Step 3/11 : COPY hello_docker.jar .\n    ---> 75c2e6ab58bd\n   Step 4/11 : RUN sh build-native.sh hello_docker.jar hello_docker\n    ---> Running in ba1e3c6403eb\n   WARNING: Unknown module: org.graalvm.nativeimage.llvm specified to --add-exports\n   WARNING: Unknown module: org.graalvm.nativeimage.llvm specified to --add-exports\n   WARNING: Unknown module: org.graalvm.nativeimage.llvm specified to --add-exports\n   ================================================================================================================\n   GraalVM Native Image: Generating 'hello_docker' (executable)...\n   ================================================================================================================\n   [1/7] Initializing...                                                                           (38.4s @ 0.41GB)\n    Version info: 'GraalVM 22.2.0 Java 11 CE'\n    Java version info: '11.0.16+8-jvmci-22.2-b06'\n    C compiler: gcc (redhat, x86_64, 8.5.0)\n    Garbage collector: Serial GC\n    2 user-specific feature(s)\n    - com.oracle.svm.thirdparty.gson.GsonFeature\n    - io.ballerina.stdlib.crypto.svm.BouncyCastleFeature\n   [2/7] Performing analysis...  [************]                                                   (171.7s @ 3.36GB)\n     25,054 (94.83%) of 26,419 classes reachable\n     81,841 (82.43%) of 99,283 fields reachable\n    147,544 (76.50%) of 192,861 methods reachable\n      1,392 classes,   712 fields, and 2,489 methods registered for reflection\n         91 classes,    93 fields, and    69 methods registered for JNI access\n          7 native libraries: dl, m, pthread, rt, stdc++, z\n   [3/7] Building universe...                                                                      (13.5s @ 3.48GB)\n   [4/7] Parsing methods...      [*****]                                                           (26.3s @ 2.43GB)\n   [5/7] Inlining methods...     [***]                                                              (8.7s @ 2.73GB)\n   [6/7] Compiling methods...    [************]                                                   (155.1s @ 2.74GB)\n   [7/7] Creating image...                                                                         (15.5s @ 2.95GB)\n     93.75MB (61.13%) for code area:   106,991 compilation units\n     59.04MB (38.49%) for image heap:  477,025 objects and 91 resources\n    594.88KB ( 0.38%) for other data\n    153.37MB in total\n   ----------------------------------------------------------------------------------------------------------------\n   Top 10 packages in code area:                          Top 10 object types in image heap:\n     19.30MB ballerina.http/2                               15.89MB byte[] for code metadata\n      4.50MB ballerina.http/2.types                         10.36MB byte[] for embedded resources\n      2.82MB ballerina.io/1                                  6.83MB java.lang.Class\n      1.91MB ballerina.file/1                                5.03MB byte[] for java.lang.String\n      1.80MB ballerina.jwt/2                                 4.60MB java.lang.String\n      1.60MB sun.security.ssl                                3.60MB byte[] for general heap data\n      1.42MB ballerina.oauth2/2                              2.29MB com.oracle.svm.core.hub.DynamicHubCompanion\n      1.25MB java.lang.invoke                                1.28MB byte[] for reflection metadata\n      1.22MB com.sun.media.sound                           974.95KB java.lang.String[]\n      1.06MB ballerina.lang$0046query/0                    926.91KB c.o.svm.core.hub.DynamicHub$ReflectionMetadata\n     56.09MB for 865 more packages                           6.28MB for 3527 more object types\n   ----------------------------------------------------------------------------------------------------------------\n              58.4s (12.6% of total time) in 124 GCs | Peak RSS: 5.41GB | CPU load: 6.50\n   ----------------------------------------------------------------------------------------------------------------\n   Produced artifacts:\n    /app/build/hello_docker (executable)\n    /app/build/hello_docker.build_artifacts.txt (txt)\n   ================================================================================================================\n   Finished generating 'hello_docker' in 6m 32s.\n   Removing intermediate container ba1e3c6403eb\n    ---> e7e7bce1a5e8\n   Step 5/11 : FROM debian:11-slim\n   11-slim: Pulling from library/debian\n   e9995326b091: Pull complete \n   Digest: sha256:e8ad0bc7d0ee6afd46e904780942033ab83b42b446b58efa88d31ecf3adf4678\n   Status: Downloaded newer image for debian:11-slim\n    ---> acdab49503b5\n   Step 6/11 : RUN useradd -ms /bin/bash ballerina\n    ---> Running in 7c97f3c18072\n   Removing intermediate container 7c97f3c18072\n    ---> 5fbbfaaf8178\n   Step 7/11 : WORKDIR /home/ballerina\n    ---> Running in e6d305ff82b5\n   Removing intermediate container e6d305ff82b5\n    ---> dd05ecf72a90\n   Step 8/11 : EXPOSE  8080\n    ---> Running in 562d3824217c\n   Removing intermediate container 562d3824217c\n    ---> f38b549838cd\n   Step 9/11 : USER ballerina\n    ---> Running in eaf7546d5caa\n   Removing intermediate container eaf7546d5caa\n    ---> a3731c04eb7e\n   Step 10/11 : COPY --from=build /app/build/hello_docker .\n    ---> bf5d0ff0d524\n   Step 11/11 : CMD [\"./hello_docker\"]\n    ---> Running in 6f65341da08a\n   Removing intermediate container 6f65341da08a\n    ---> 47c7a10a79ef\n   Successfully built 47c7a10a79ef\n   Successfully tagged wso2inc/hello:v0.1.0\n\n   Execute the below command to run the generated Docker image: \n       docker run -d -p 8080:8080 wso2inc/hello:v0.1.0\n\n       target/bin/hello_docker.jar\n   ```\n\n   Further optionally you can create a file named Cloud.toml in the package directory and add the content below. The values below describe the image being generated. For more information please see the [docker](https://ballerina.io/learn/by-example/c2c-docker-deployment/) and [k8s](https://ballerina.io/learn/by-example/c2c-k8s-deployment/) documentation.\n\n   ```toml\n   [container.image]\n   repository=\"wso2inc\" # ex - Docker hub name\n   name=\"hello\" # container name\n   tag=\"v0.1.0\"\n   ```\n\n   The docker file :\n   ```\t\n   # Auto Generated Dockerfile\n   FROM ballerina/native-builder:latest as build\n\n   WORKDIR /app/build\n\n   COPY hello_docker.jar .\n\n   RUN sh build-native.sh hello_docker.jar hello_docker\n\n   FROM debian:11-slim\n\n   RUN useradd -ms /bin/bash ballerina\n   WORKDIR /home/ballerina\n\n   EXPOSE  8080\n   USER ballerina\n\n   COPY --from=build /app/build/hello_docker .\n\n   CMD [\"./hello_docker\"]\n   ```\n\n4. Execute the docker image :\n   ```\n   $ docker run -d -p 8080:8080 wso2inc/hello:v0.1.0\n   ```\n\n5. Testing the service with a curl request :\n   ```\n   $ curl http://localhost:8080/greeting\n   Hello, Docker!\n   ```\n","id":"build-a-native-executable","sub":"native-support","third":"","slug":"native-support/build-a-native-executable"},"__N_SSG":true}